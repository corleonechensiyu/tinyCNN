// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CAFFEOP_TCNN_H_
#define FLATBUFFERS_GENERATED_CAFFEOP_TCNN_H_

#include "flatbuffers/flatbuffers.h"

namespace TCNN {

struct Convolution2DCommon;
struct Convolution2DCommonT;

struct Convolution2D;
struct Convolution2DT;

struct InnerProduct;
struct InnerProductT;

struct Pooling;
struct PoolingT;

struct Softmax;
struct SoftmaxT;

struct ReLU;
struct ReLUT;

struct Input;
struct InputT;

inline const flatbuffers::TypeTable *Convolution2DCommonTypeTable();

inline const flatbuffers::TypeTable *Convolution2DTypeTable();

inline const flatbuffers::TypeTable *InnerProductTypeTable();

inline const flatbuffers::TypeTable *PoolingTypeTable();

inline const flatbuffers::TypeTable *SoftmaxTypeTable();

inline const flatbuffers::TypeTable *ReLUTypeTable();

inline const flatbuffers::TypeTable *InputTypeTable();

enum PadMode {
  PadMode_CAFFE = 0,
  PadMode_VALID = 1,
  PadMode_SAME = 2,
  PadMode_MIN = PadMode_CAFFE,
  PadMode_MAX = PadMode_SAME
};

inline const PadMode (&EnumValuesPadMode())[3] {
  static const PadMode values[] = {
    PadMode_CAFFE,
    PadMode_VALID,
    PadMode_SAME
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (e < PadMode_CAFFE || e > PadMode_SAME) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPadMode()[index];
}

enum PoolType {
  PoolType_MAXPOOL = 0,
  PoolType_AVEPOOL = 1,
  PoolType_MIN = PoolType_MAXPOOL,
  PoolType_MAX = PoolType_AVEPOOL
};

inline const PoolType (&EnumValuesPoolType())[2] {
  static const PoolType values[] = {
    PoolType_MAXPOOL,
    PoolType_AVEPOOL
  };
  return values;
}

inline const char * const *EnumNamesPoolType() {
  static const char * const names[] = {
    "MAXPOOL",
    "AVEPOOL",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolType(PoolType e) {
  if (e < PoolType_MAXPOOL || e > PoolType_AVEPOOL) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPoolType()[index];
}

enum PoolPadType {
  PoolPadType_CAFFE = 0,
  PoolPadType_VALID = 1,
  PoolPadType_SAME = 2,
  PoolPadType_MIN = PoolPadType_CAFFE,
  PoolPadType_MAX = PoolPadType_SAME
};

inline const PoolPadType (&EnumValuesPoolPadType())[3] {
  static const PoolPadType values[] = {
    PoolPadType_CAFFE,
    PoolPadType_VALID,
    PoolPadType_SAME
  };
  return values;
}

inline const char * const *EnumNamesPoolPadType() {
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolPadType(PoolPadType e) {
  if (e < PoolPadType_CAFFE || e > PoolPadType_SAME) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesPoolPadType()[index];
}

struct Convolution2DCommonT : public flatbuffers::NativeTable {
  typedef Convolution2DCommon TableType;
  int32_t padX;
  int32_t padY;
  int32_t kernelX;
  int32_t kernelY;
  int32_t strideX;
  int32_t strideY;
  int32_t dilateX;
  int32_t dilateY;
  PadMode padMode;
  int32_t group;
  int32_t outputCount;
  int32_t inputCount;
  bool relu;
  bool relu6;
  std::vector<int32_t> pads;
  Convolution2DCommonT()
      : padX(0),
        padY(0),
        kernelX(1),
        kernelY(1),
        strideX(1),
        strideY(1),
        dilateX(1),
        dilateY(1),
        padMode(PadMode_CAFFE),
        group(1),
        outputCount(0),
        inputCount(0),
        relu(false),
        relu6(false) {
  }
};

struct Convolution2DCommon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution2DCommonT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution2DCommonTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADX = 4,
    VT_PADY = 6,
    VT_KERNELX = 8,
    VT_KERNELY = 10,
    VT_STRIDEX = 12,
    VT_STRIDEY = 14,
    VT_DILATEX = 16,
    VT_DILATEY = 18,
    VT_PADMODE = 20,
    VT_GROUP = 22,
    VT_OUTPUTCOUNT = 24,
    VT_INPUTCOUNT = 26,
    VT_RELU = 28,
    VT_RELU6 = 30,
    VT_PADS = 32
  };
  int32_t padX() const {
    return GetField<int32_t>(VT_PADX, 0);
  }
  int32_t padY() const {
    return GetField<int32_t>(VT_PADY, 0);
  }
  int32_t kernelX() const {
    return GetField<int32_t>(VT_KERNELX, 1);
  }
  int32_t kernelY() const {
    return GetField<int32_t>(VT_KERNELY, 1);
  }
  int32_t strideX() const {
    return GetField<int32_t>(VT_STRIDEX, 1);
  }
  int32_t strideY() const {
    return GetField<int32_t>(VT_STRIDEY, 1);
  }
  int32_t dilateX() const {
    return GetField<int32_t>(VT_DILATEX, 1);
  }
  int32_t dilateY() const {
    return GetField<int32_t>(VT_DILATEY, 1);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 1);
  }
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  int32_t inputCount() const {
    return GetField<int32_t>(VT_INPUTCOUNT, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(VT_RELU, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(VT_RELU6, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PADX) &&
           VerifyField<int32_t>(verifier, VT_PADY) &&
           VerifyField<int32_t>(verifier, VT_KERNELX) &&
           VerifyField<int32_t>(verifier, VT_KERNELY) &&
           VerifyField<int32_t>(verifier, VT_STRIDEX) &&
           VerifyField<int32_t>(verifier, VT_STRIDEY) &&
           VerifyField<int32_t>(verifier, VT_DILATEX) &&
           VerifyField<int32_t>(verifier, VT_DILATEY) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT) &&
           VerifyField<int32_t>(verifier, VT_INPUTCOUNT) &&
           VerifyField<uint8_t>(verifier, VT_RELU) &&
           VerifyField<uint8_t>(verifier, VT_RELU6) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           verifier.EndTable();
  }
  Convolution2DCommonT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution2DCommonT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution2DCommon> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution2DCommonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padX(int32_t padX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_PADX, padX, 0);
  }
  void add_padY(int32_t padY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_PADY, padY, 0);
  }
  void add_kernelX(int32_t kernelX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_KERNELX, kernelX, 1);
  }
  void add_kernelY(int32_t kernelY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_KERNELY, kernelY, 1);
  }
  void add_strideX(int32_t strideX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_STRIDEX, strideX, 1);
  }
  void add_strideY(int32_t strideY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_STRIDEY, strideY, 1);
  }
  void add_dilateX(int32_t dilateX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_DILATEX, dilateX, 1);
  }
  void add_dilateY(int32_t dilateY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_DILATEY, dilateY, 1);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(Convolution2DCommon::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_GROUP, group, 1);
  }
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_inputCount(int32_t inputCount) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_INPUTCOUNT, inputCount, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(Convolution2DCommon::VT_RELU, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(Convolution2DCommon::VT_RELU6, static_cast<uint8_t>(relu6), 0);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Convolution2DCommon::VT_PADS, pads);
  }
  explicit Convolution2DCommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Convolution2DCommonBuilder &operator=(const Convolution2DCommonBuilder &);
  flatbuffers::Offset<Convolution2DCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution2DCommon>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    int32_t kernelX = 1,
    int32_t kernelY = 1,
    int32_t strideX = 1,
    int32_t strideY = 1,
    int32_t dilateX = 1,
    int32_t dilateY = 1,
    PadMode padMode = PadMode_CAFFE,
    int32_t group = 1,
    int32_t outputCount = 0,
    int32_t inputCount = 0,
    bool relu = false,
    bool relu6 = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0) {
  Convolution2DCommonBuilder builder_(_fbb);
  builder_.add_pads(pads);
  builder_.add_inputCount(inputCount);
  builder_.add_outputCount(outputCount);
  builder_.add_group(group);
  builder_.add_dilateY(dilateY);
  builder_.add_dilateX(dilateX);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_kernelY(kernelY);
  builder_.add_kernelX(kernelX);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommonDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    int32_t kernelX = 1,
    int32_t kernelY = 1,
    int32_t strideX = 1,
    int32_t strideY = 1,
    int32_t dilateX = 1,
    int32_t dilateY = 1,
    PadMode padMode = PadMode_CAFFE,
    int32_t group = 1,
    int32_t outputCount = 0,
    int32_t inputCount = 0,
    bool relu = false,
    bool relu6 = false,
    const std::vector<int32_t> *pads = nullptr) {
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  return TCNN::CreateConvolution2DCommon(
      _fbb,
      padX,
      padY,
      kernelX,
      kernelY,
      strideX,
      strideY,
      dilateX,
      dilateY,
      padMode,
      group,
      outputCount,
      inputCount,
      relu,
      relu6,
      pads__);
}

flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Convolution2DT : public flatbuffers::NativeTable {
  typedef Convolution2D TableType;
  std::unique_ptr<Convolution2DCommonT> common;
  std::vector<float> weight;
  std::vector<float> bias;
  Convolution2DT() {
  }
};

struct Convolution2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Convolution2DT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Convolution2DTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8
  };
  const Convolution2DCommon *common() const {
    return GetPointer<const Convolution2DCommon *>(VT_COMMON);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           verifier.EndTable();
  }
  Convolution2DT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Convolution2DT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Convolution2D> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Convolution2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<Convolution2DCommon> common) {
    fbb_.AddOffset(Convolution2D::VT_COMMON, common);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(Convolution2D::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(Convolution2D::VT_BIAS, bias);
  }
  explicit Convolution2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Convolution2DBuilder &operator=(const Convolution2DBuilder &);
  flatbuffers::Offset<Convolution2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Convolution2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Convolution2D> CreateConvolution2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Convolution2DCommon> common = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0) {
  Convolution2DBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_common(common);
  return builder_.Finish();
}

inline flatbuffers::Offset<Convolution2D> CreateConvolution2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Convolution2DCommon> common = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  return TCNN::CreateConvolution2D(
      _fbb,
      common,
      weight__,
      bias__);
}

flatbuffers::Offset<Convolution2D> CreateConvolution2D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InnerProductT : public flatbuffers::NativeTable {
  typedef InnerProduct TableType;
  int32_t outputCount;
  int32_t biasTerm;
  int32_t weightSize;
  std::vector<float> weight;
  std::vector<float> bias;
  int32_t axis;
  InnerProductT()
      : outputCount(0),
        biasTerm(0),
        weightSize(0),
        axis(0) {
  }
};

struct InnerProduct FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InnerProductT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InnerProductTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTCOUNT = 4,
    VT_BIASTERM = 6,
    VT_WEIGHTSIZE = 8,
    VT_WEIGHT = 10,
    VT_BIAS = 12,
    VT_AXIS = 14
  };
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  int32_t biasTerm() const {
    return GetField<int32_t>(VT_BIASTERM, 0);
  }
  int32_t weightSize() const {
    return GetField<int32_t>(VT_WEIGHTSIZE, 0);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT) &&
           VerifyField<int32_t>(verifier, VT_BIASTERM) &&
           VerifyField<int32_t>(verifier, VT_WEIGHTSIZE) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  InnerProductT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InnerProductT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InnerProduct> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InnerProductBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_biasTerm(int32_t biasTerm) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_BIASTERM, biasTerm, 0);
  }
  void add_weightSize(int32_t weightSize) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_WEIGHTSIZE, weightSize, 0);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(InnerProduct::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(InnerProduct::VT_BIAS, bias);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_AXIS, axis, 0);
  }
  explicit InnerProductBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InnerProductBuilder &operator=(const InnerProductBuilder &);
  flatbuffers::Offset<InnerProduct> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InnerProduct>(end);
    return o;
  }
};

inline flatbuffers::Offset<InnerProduct> CreateInnerProduct(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t biasTerm = 0,
    int32_t weightSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    int32_t axis = 0) {
  InnerProductBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_weightSize(weightSize);
  builder_.add_biasTerm(biasTerm);
  builder_.add_outputCount(outputCount);
  return builder_.Finish();
}

inline flatbuffers::Offset<InnerProduct> CreateInnerProductDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t biasTerm = 0,
    int32_t weightSize = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    int32_t axis = 0) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  return TCNN::CreateInnerProduct(
      _fbb,
      outputCount,
      biasTerm,
      weightSize,
      weight__,
      bias__,
      axis);
}

flatbuffers::Offset<InnerProduct> CreateInnerProduct(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PoolingT : public flatbuffers::NativeTable {
  typedef Pooling TableType;
  int32_t padX;
  int32_t padY;
  bool isGlobal;
  int32_t kernelX;
  int32_t kernelY;
  int32_t strideX;
  int32_t strideY;
  PoolType type;
  PoolPadType padType;
  bool ceilModel;
  std::vector<int32_t> pads;
  PoolingT()
      : padX(0),
        padY(0),
        isGlobal(false),
        kernelX(0),
        kernelY(0),
        strideX(0),
        strideY(0),
        type(PoolType_MAXPOOL),
        padType(PoolPadType_CAFFE),
        ceilModel(true) {
  }
};

struct Pooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoolingT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PoolingTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADX = 4,
    VT_PADY = 6,
    VT_ISGLOBAL = 8,
    VT_KERNELX = 10,
    VT_KERNELY = 12,
    VT_STRIDEX = 14,
    VT_STRIDEY = 16,
    VT_TYPE = 18,
    VT_PADTYPE = 20,
    VT_CEILMODEL = 22,
    VT_PADS = 24
  };
  int32_t padX() const {
    return GetField<int32_t>(VT_PADX, 0);
  }
  int32_t padY() const {
    return GetField<int32_t>(VT_PADY, 0);
  }
  bool isGlobal() const {
    return GetField<uint8_t>(VT_ISGLOBAL, 0) != 0;
  }
  int32_t kernelX() const {
    return GetField<int32_t>(VT_KERNELX, 0);
  }
  int32_t kernelY() const {
    return GetField<int32_t>(VT_KERNELY, 0);
  }
  int32_t strideX() const {
    return GetField<int32_t>(VT_STRIDEX, 0);
  }
  int32_t strideY() const {
    return GetField<int32_t>(VT_STRIDEY, 0);
  }
  PoolType type() const {
    return static_cast<PoolType>(GetField<int8_t>(VT_TYPE, 0));
  }
  PoolPadType padType() const {
    return static_cast<PoolPadType>(GetField<int8_t>(VT_PADTYPE, 0));
  }
  bool ceilModel() const {
    return GetField<uint8_t>(VT_CEILMODEL, 1) != 0;
  }
  const flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PADX) &&
           VerifyField<int32_t>(verifier, VT_PADY) &&
           VerifyField<uint8_t>(verifier, VT_ISGLOBAL) &&
           VerifyField<int32_t>(verifier, VT_KERNELX) &&
           VerifyField<int32_t>(verifier, VT_KERNELY) &&
           VerifyField<int32_t>(verifier, VT_STRIDEX) &&
           VerifyField<int32_t>(verifier, VT_STRIDEY) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int8_t>(verifier, VT_PADTYPE) &&
           VerifyField<uint8_t>(verifier, VT_CEILMODEL) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           verifier.EndTable();
  }
  PoolingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PoolingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pooling> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoolingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padX(int32_t padX) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADX, padX, 0);
  }
  void add_padY(int32_t padY) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADY, padY, 0);
  }
  void add_isGlobal(bool isGlobal) {
    fbb_.AddElement<uint8_t>(Pooling::VT_ISGLOBAL, static_cast<uint8_t>(isGlobal), 0);
  }
  void add_kernelX(int32_t kernelX) {
    fbb_.AddElement<int32_t>(Pooling::VT_KERNELX, kernelX, 0);
  }
  void add_kernelY(int32_t kernelY) {
    fbb_.AddElement<int32_t>(Pooling::VT_KERNELY, kernelY, 0);
  }
  void add_strideX(int32_t strideX) {
    fbb_.AddElement<int32_t>(Pooling::VT_STRIDEX, strideX, 0);
  }
  void add_strideY(int32_t strideY) {
    fbb_.AddElement<int32_t>(Pooling::VT_STRIDEY, strideY, 0);
  }
  void add_type(PoolType type) {
    fbb_.AddElement<int8_t>(Pooling::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_padType(PoolPadType padType) {
    fbb_.AddElement<int8_t>(Pooling::VT_PADTYPE, static_cast<int8_t>(padType), 0);
  }
  void add_ceilModel(bool ceilModel) {
    fbb_.AddElement<uint8_t>(Pooling::VT_CEILMODEL, static_cast<uint8_t>(ceilModel), 1);
  }
  void add_pads(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Pooling::VT_PADS, pads);
  }
  explicit PoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoolingBuilder &operator=(const PoolingBuilder &);
  flatbuffers::Offset<Pooling> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pooling>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pooling> CreatePooling(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    bool isGlobal = false,
    int32_t kernelX = 0,
    int32_t kernelY = 0,
    int32_t strideX = 0,
    int32_t strideY = 0,
    PoolType type = PoolType_MAXPOOL,
    PoolPadType padType = PoolPadType_CAFFE,
    bool ceilModel = true,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pads = 0) {
  PoolingBuilder builder_(_fbb);
  builder_.add_pads(pads);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_kernelY(kernelY);
  builder_.add_kernelX(kernelX);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_ceilModel(ceilModel);
  builder_.add_padType(padType);
  builder_.add_type(type);
  builder_.add_isGlobal(isGlobal);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pooling> CreatePoolingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    bool isGlobal = false,
    int32_t kernelX = 0,
    int32_t kernelY = 0,
    int32_t strideX = 0,
    int32_t strideY = 0,
    PoolType type = PoolType_MAXPOOL,
    PoolPadType padType = PoolPadType_CAFFE,
    bool ceilModel = true,
    const std::vector<int32_t> *pads = nullptr) {
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  return TCNN::CreatePooling(
      _fbb,
      padX,
      padY,
      isGlobal,
      kernelX,
      kernelY,
      strideX,
      strideY,
      type,
      padType,
      ceilModel,
      pads__);
}

flatbuffers::Offset<Pooling> CreatePooling(flatbuffers::FlatBufferBuilder &_fbb, const PoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SoftmaxT : public flatbuffers::NativeTable {
  typedef Softmax TableType;
  int32_t axis;
  SoftmaxT()
      : axis(0) {
  }
};

struct Softmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftmaxT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SoftmaxTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
  SoftmaxT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SoftmaxT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Softmax> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SoftmaxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Softmax::VT_AXIS, axis, 0);
  }
  explicit SoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxBuilder &operator=(const SoftmaxBuilder &);
  flatbuffers::Offset<Softmax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Softmax>(end);
    return o;
  }
};

inline flatbuffers::Offset<Softmax> CreateSoftmax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  SoftmaxBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

flatbuffers::Offset<Softmax> CreateSoftmax(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReLUT : public flatbuffers::NativeTable {
  typedef ReLU TableType;
  float slope;
  ReLUT()
      : slope(0.0f) {
  }
};

struct ReLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReLUT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReLUTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOPE = 4
  };
  float slope() const {
    return GetField<float>(VT_SLOPE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SLOPE) &&
           verifier.EndTable();
  }
  ReLUT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReLUT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ReLU> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReLUT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReLUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slope(float slope) {
    fbb_.AddElement<float>(ReLU::VT_SLOPE, slope, 0.0f);
  }
  explicit ReLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReLUBuilder &operator=(const ReLUBuilder &);
  flatbuffers::Offset<ReLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReLU>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReLU> CreateReLU(
    flatbuffers::FlatBufferBuilder &_fbb,
    float slope = 0.0f) {
  ReLUBuilder builder_(_fbb);
  builder_.add_slope(slope);
  return builder_.Finish();
}

flatbuffers::Offset<ReLU> CreateReLU(flatbuffers::FlatBufferBuilder &_fbb, const ReLUT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InputT : public flatbuffers::NativeTable {
  typedef Input TableType;
  std::vector<int32_t> dims;
  InputT() {
  }
};

struct Input FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InputT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InputTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
  InputT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InputT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Input> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Input::VT_DIMS, dims);
  }
  explicit InputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InputBuilder &operator=(const InputBuilder &);
  flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline flatbuffers::Offset<Input> CreateInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0) {
  InputBuilder builder_(_fbb);
  builder_.add_dims(dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<Input> CreateInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return TCNN::CreateInput(
      _fbb,
      dims__);
}

flatbuffers::Offset<Input> CreateInput(flatbuffers::FlatBufferBuilder &_fbb, const InputT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Convolution2DCommonT *Convolution2DCommon::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Convolution2DCommonT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Convolution2DCommon::UnPackTo(Convolution2DCommonT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padX(); _o->padX = _e; };
  { auto _e = padY(); _o->padY = _e; };
  { auto _e = kernelX(); _o->kernelX = _e; };
  { auto _e = kernelY(); _o->kernelY = _e; };
  { auto _e = strideX(); _o->strideX = _e; };
  { auto _e = strideY(); _o->strideY = _e; };
  { auto _e = dilateX(); _o->dilateX = _e; };
  { auto _e = dilateY(); _o->dilateY = _e; };
  { auto _e = padMode(); _o->padMode = _e; };
  { auto _e = group(); _o->group = _e; };
  { auto _e = outputCount(); _o->outputCount = _e; };
  { auto _e = inputCount(); _o->inputCount = _e; };
  { auto _e = relu(); _o->relu = _e; };
  { auto _e = relu6(); _o->relu6 = _e; };
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Convolution2DCommon> Convolution2DCommon::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution2DCommon(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommon(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DCommonT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution2DCommonT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padX = _o->padX;
  auto _padY = _o->padY;
  auto _kernelX = _o->kernelX;
  auto _kernelY = _o->kernelY;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  auto _dilateX = _o->dilateX;
  auto _dilateY = _o->dilateY;
  auto _padMode = _o->padMode;
  auto _group = _o->group;
  auto _outputCount = _o->outputCount;
  auto _inputCount = _o->inputCount;
  auto _relu = _o->relu;
  auto _relu6 = _o->relu6;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  return TCNN::CreateConvolution2DCommon(
      _fbb,
      _padX,
      _padY,
      _kernelX,
      _kernelY,
      _strideX,
      _strideY,
      _dilateX,
      _dilateY,
      _padMode,
      _group,
      _outputCount,
      _inputCount,
      _relu,
      _relu6,
      _pads);
}

inline Convolution2DT *Convolution2D::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Convolution2DT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Convolution2D::UnPackTo(Convolution2DT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = common(); if (_e) _o->common = std::unique_ptr<Convolution2DCommonT>(_e->UnPack(_resolver)); };
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Convolution2D> Convolution2D::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConvolution2D(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Convolution2D> CreateConvolution2D(flatbuffers::FlatBufferBuilder &_fbb, const Convolution2DT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Convolution2DT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _common = _o->common ? CreateConvolution2DCommon(_fbb, _o->common.get(), _rehasher) : 0;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  return TCNN::CreateConvolution2D(
      _fbb,
      _common,
      _weight,
      _bias);
}

inline InnerProductT *InnerProduct::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InnerProductT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void InnerProduct::UnPackTo(InnerProductT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outputCount(); _o->outputCount = _e; };
  { auto _e = biasTerm(); _o->biasTerm = _e; };
  { auto _e = weightSize(); _o->weightSize = _e; };
  { auto _e = weight(); if (_e) { _o->weight.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weight[_i] = _e->Get(_i); } } };
  { auto _e = bias(); if (_e) { _o->bias.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bias[_i] = _e->Get(_i); } } };
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<InnerProduct> InnerProduct::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInnerProduct(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InnerProduct> CreateInnerProduct(flatbuffers::FlatBufferBuilder &_fbb, const InnerProductT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InnerProductT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outputCount = _o->outputCount;
  auto _biasTerm = _o->biasTerm;
  auto _weightSize = _o->weightSize;
  auto _weight = _o->weight.size() ? _fbb.CreateVector(_o->weight) : 0;
  auto _bias = _o->bias.size() ? _fbb.CreateVector(_o->bias) : 0;
  auto _axis = _o->axis;
  return TCNN::CreateInnerProduct(
      _fbb,
      _outputCount,
      _biasTerm,
      _weightSize,
      _weight,
      _bias,
      _axis);
}

inline PoolingT *Pooling::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PoolingT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Pooling::UnPackTo(PoolingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = padX(); _o->padX = _e; };
  { auto _e = padY(); _o->padY = _e; };
  { auto _e = isGlobal(); _o->isGlobal = _e; };
  { auto _e = kernelX(); _o->kernelX = _e; };
  { auto _e = kernelY(); _o->kernelY = _e; };
  { auto _e = strideX(); _o->strideX = _e; };
  { auto _e = strideY(); _o->strideY = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = padType(); _o->padType = _e; };
  { auto _e = ceilModel(); _o->ceilModel = _e; };
  { auto _e = pads(); if (_e) { _o->pads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pads[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Pooling> Pooling::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PoolingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePooling(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pooling> CreatePooling(flatbuffers::FlatBufferBuilder &_fbb, const PoolingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PoolingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _padX = _o->padX;
  auto _padY = _o->padY;
  auto _isGlobal = _o->isGlobal;
  auto _kernelX = _o->kernelX;
  auto _kernelY = _o->kernelY;
  auto _strideX = _o->strideX;
  auto _strideY = _o->strideY;
  auto _type = _o->type;
  auto _padType = _o->padType;
  auto _ceilModel = _o->ceilModel;
  auto _pads = _o->pads.size() ? _fbb.CreateVector(_o->pads) : 0;
  return TCNN::CreatePooling(
      _fbb,
      _padX,
      _padY,
      _isGlobal,
      _kernelX,
      _kernelY,
      _strideX,
      _strideY,
      _type,
      _padType,
      _ceilModel,
      _pads);
}

inline SoftmaxT *Softmax::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SoftmaxT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Softmax::UnPackTo(SoftmaxT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = axis(); _o->axis = _e; };
}

inline flatbuffers::Offset<Softmax> Softmax::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSoftmax(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Softmax> CreateSoftmax(flatbuffers::FlatBufferBuilder &_fbb, const SoftmaxT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SoftmaxT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _axis = _o->axis;
  return TCNN::CreateSoftmax(
      _fbb,
      _axis);
}

inline ReLUT *ReLU::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReLUT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ReLU::UnPackTo(ReLUT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slope(); _o->slope = _e; };
}

inline flatbuffers::Offset<ReLU> ReLU::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReLUT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReLU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ReLU> CreateReLU(flatbuffers::FlatBufferBuilder &_fbb, const ReLUT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReLUT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slope = _o->slope;
  return TCNN::CreateReLU(
      _fbb,
      _slope);
}

inline InputT *Input::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InputT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Input::UnPackTo(InputT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dims(); if (_e) { _o->dims.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dims[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Input> Input::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InputT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInput(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Input> CreateInput(flatbuffers::FlatBufferBuilder &_fbb, const InputT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InputT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dims = _o->dims.size() ? _fbb.CreateVector(_o->dims) : 0;
  return TCNN::CreateInput(
      _fbb,
      _dims);
}

inline const flatbuffers::TypeTable *PadModeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PadModeTypeTable
  };
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolTypeTypeTable
  };
  static const char * const names[] = {
    "MAXPOOL",
    "AVEPOOL"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolPadTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolPadTypeTypeTable
  };
  static const char * const names[] = {
    "CAFFE",
    "VALID",
    "SAME"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution2DCommonTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PadModeTypeTable
  };
  static const char * const names[] = {
    "padX",
    "padY",
    "kernelX",
    "kernelY",
    "strideX",
    "strideY",
    "dilateX",
    "dilateY",
    "padMode",
    "group",
    "outputCount",
    "inputCount",
    "relu",
    "relu6",
    "pads"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 15, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Convolution2DTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Convolution2DCommonTypeTable
  };
  static const char * const names[] = {
    "common",
    "weight",
    "bias"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InnerProductTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "outputCount",
    "biasTerm",
    "weightSize",
    "weight",
    "bias",
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PoolingTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PoolTypeTypeTable,
    PoolPadTypeTypeTable
  };
  static const char * const names[] = {
    "padX",
    "padY",
    "isGlobal",
    "kernelX",
    "kernelY",
    "strideX",
    "strideY",
    "type",
    "padType",
    "ceilModel",
    "pads"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SoftmaxTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "axis"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReLUTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "slope"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InputTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "dims"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace TCNN

#endif  // FLATBUFFERS_GENERATED_CAFFEOP_TCNN_H_
